{"ast":null,"code":"\"use strict\";\n\n/*!\r\n * crypto-convert (c) 2022\r\n * Author: Elis\r\n * License: https://github.com/coinconvert/crypto-convert\r\n */\nrequire(\"core-js/modules/es.iterator.constructor.js\");\nrequire(\"core-js/modules/es.iterator.filter.js\");\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _CryptoConvert_instances, _CryptoConvert_getPrice, _CryptoConvert_wrapper, _CryptoConvert_isSafeKey, _CryptoConvert_setExtendedOptions, _CryptoConvert_populate;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst helpers_1 = require(\"./helpers\");\nconst worker_1 = __importDefault(require(\"./worker\"));\nconst custom_1 = __importDefault(require(\"./custom\"));\nconst customWorkers = new custom_1.default();\nclass CryptoConvert {\n  constructor(options = {}) {\n    _CryptoConvert_instances.add(this);\n    this.precision = {\n      fiat: 4,\n      crypto: 8\n    };\n    if (helpers_1.isBrowser) {\n      if (window['__ccInitialized']) {\n        throw new Error(\"You have already initalized one instance of crypto-convert. You cannot initialize multiple instances.\");\n      }\n      window['__ccInitialized'] = true;\n    }\n    __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_setExtendedOptions).call(this, options);\n    this.worker = new worker_1.default(options);\n    this.workerReady = this.worker.run();\n    this.internalMethods = Object.getOwnPropertyNames(CryptoConvert.prototype);\n    Promise.resolve(this.workerReady).then(() => {\n      __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_populate).call(this);\n      this.worker.onCryptoListRefresh = () => {\n        __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_populate).call(this);\n      };\n    });\n  }\n  /**\r\n   * Quick check if cache has loaded.\r\n   */\n  get isReady() {\n    return this.worker.isReady;\n  }\n  /**\r\n   * Supported currencies list\r\n   */\n  get list() {\n    return {\n      'crypto': this.worker.list.crypto.concat(customWorkers.list),\n      'fiat': this.worker.list.fiat\n    };\n  }\n  /**\r\n   * Metadata information about cryptocurrencies\r\n   */\n  get cryptoInfo() {\n    return this.worker.cryptoInfo;\n  }\n  /**\r\n   * Get crypto prices last updated ms\r\n   */\n  get lastUpdated() {\n    return this.worker.data.crypto.last_updated;\n  }\n  /**\r\n   * Price Tickers\r\n   */\n  get ticker() {\n    return this.worker.data;\n  }\n  /**\r\n   * Update options\r\n   */\n  setOptions(options) {\n    __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_setExtendedOptions).call(this, options);\n    const workerIntervalChanged = (options.cryptoInterval || options.fiatInterval) && (options.cryptoInterval !== this.worker.options.cryptoInterval || options.fiatInterval !== this.worker.options.fiatInterval);\n    if (workerIntervalChanged || options.hasOwnProperty('refreshCryptoList') && options.refreshCryptoList !== this.worker.options.refreshCryptoList || options.hasOwnProperty('useHostedAPI') && options.useHostedAPI !== this.worker.options.useHostedAPI || options.listLimit && options.listLimit != this.worker.options.listLimit) {\n      if (!this.worker.isReady) {\n        throw new Error(\"You cannot set these options here because CryptoConvert is not ready yet. Instead set the options on the constructor parameter.\");\n      }\n      //Restart the worker in order to clear interval & update to new interval\n      this.workerReady = Promise.resolve(this.worker.setOptions(options)).then(() => __awaiter(this, void 0, void 0, function* () {\n        yield this.worker.restart();\n        if (options.listLimit) {\n          __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_populate).call(this);\n        }\n        return this.worker;\n      }));\n      return this.worker;\n    }\n    return this.worker.setOptions(options);\n  }\n  /**\r\n   * Stop the worker.\r\n   *\r\n   * It's recommended to do this on Component unmounts (i.e if you are using React).\r\n   */\n  stop() {\n    return this.worker.stop();\n  }\n  /**\r\n   * Re-start the worker when it has been stopped.\r\n   */\n  restart() {\n    this.workerReady = this.worker.restart();\n    return this.workerReady;\n  }\n  /**\r\n   * Promise function that resolves when cache has loaded.\r\n   */\n  ready() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield Promise.resolve(this.workerReady);\n      yield Promise.resolve(customWorkers.ready());\n      return this;\n    });\n  }\n  /**\r\n   * Add a custom currency fetcher. Can be anything.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * convert.addCurrency('ANY','USD', async fetchPrice()=>{\r\n   * \t\t//...call your api here\r\n   * \t\treturn price;\r\n   * }, 10000);\r\n   * ```\r\n   */\n  addCurrency(base, ...rest) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.hasOwnProperty(base)) {\n        throw new Error(\"This property already exists.\");\n      }\n      return Promise.resolve(customWorkers.addCurrency.apply(customWorkers, [base, ...rest])).then(() => {\n        if (this.worker.isReady) {\n          __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_populate).call(this);\n        }\n      });\n    });\n  }\n  /**\r\n   * Remove custom currency fetcher.\r\n   */\n  removeCurrency(base, quote) {\n    var _a, _b;\n    if (customWorkers.list.includes(base) && __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_isSafeKey).call(this, base)) {\n      delete this[base];\n      const all_currencies = this.worker.list.crypto.concat(this.worker.list.fiat, customWorkers.list);\n      for (const currency of all_currencies) {\n        if ((_a = this[currency]) === null || _a === void 0 ? void 0 : _a[base]) {\n          (_b = this[currency]) === null || _b === void 0 ? true : delete _b[base];\n        }\n      }\n    }\n    return customWorkers.removeCurrency(base, quote);\n  }\n}\n_CryptoConvert_instances = new WeakSet(), _CryptoConvert_getPrice = function _CryptoConvert_getPrice(coin, to = 'USD') {\n  var customResult = customWorkers.ticker[coin + to] || (customWorkers.ticker[to + coin] ? 1 / customWorkers.ticker[to + coin] : null);\n  var result = this.worker.data.crypto.current[coin + to] || (this.worker.data.crypto.current[to + coin] ? 1 / this.worker.data.crypto.current[to + coin] : null);\n  return customResult || result;\n}, _CryptoConvert_wrapper = function _CryptoConvert_wrapper(coin, currency) {\n  var coin = coin;\n  var toCurrency = currency;\n  const doExchange = function (fromAmount) {\n    if ((0, helpers_1.isEmpty)(this.worker.data.crypto.current) || (0, helpers_1.isEmpty)(this.worker.data.fiat.current)) {\n      console.warn(\"[~] Prices are loading.\\nYou should use `await convert.ready()` to make sure prices are loaded before calling convert.\");\n      return false;\n    }\n    if (!fromAmount) {\n      return false;\n    }\n    fromAmount = (0, helpers_1.formatNumber)(fromAmount);\n    if (isNaN(fromAmount)) {\n      return false;\n    }\n    const fiatCurrencies = this.worker.data.fiat.current;\n    const cryptoCurrenciesList = this.worker.list.crypto.concat(customWorkers.list);\n    //Same\n    if (toCurrency == coin) {\n      return fromAmount;\n    }\n    //Crypto to Crypto\n    if (cryptoCurrenciesList.includes(coin) && cryptoCurrenciesList.includes(toCurrency)) {\n      let exchangePrice = __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_getPrice).call(this, coin, toCurrency) || __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_wrapper).call(this, \"USD\", toCurrency)(__classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_wrapper).call(this, coin, \"USD\")(1));\n      return (0, helpers_1.formatNumber)(exchangePrice * fromAmount, this.precision.crypto);\n    }\n    //Fiat to Fiat\n    if (fiatCurrencies[coin] && fiatCurrencies[toCurrency]) {\n      return (0, helpers_1.formatNumber)(fromAmount / fiatCurrencies[coin] * fiatCurrencies[toCurrency], this.precision.fiat);\n    }\n    //Crypto->Fiat || Crypto->BTC->Fiat\n    var getCryptoPrice = function (coin) {\n      var coinPrice = __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_getPrice).call(this, coin) || __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_wrapper).call(this, \"BTC\", \"USD\")(__classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_getPrice).call(this, coin, \"BTC\")) || __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_wrapper).call(this, \"ETH\", \"USD\")(__classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_getPrice).call(this, coin, \"ETH\"));\n      return coinPrice;\n    }.bind(this);\n    //Crypto to Fiat\n    if (fiatCurrencies[toCurrency]) {\n      let usdPrice = getCryptoPrice(coin);\n      let exchangePrice = usdPrice / fiatCurrencies['USD'] * fiatCurrencies[toCurrency]; //Convert USD to chosen FIAT\n      return (0, helpers_1.formatNumber)(exchangePrice * fromAmount, this.precision.crypto);\n    }\n    //Fiat to Crypto\n    if (fiatCurrencies[coin]) {\n      let usdPrice = getCryptoPrice(toCurrency);\n      let exchangePrice = usdPrice / fiatCurrencies['USD'] * fiatCurrencies[coin]; //Convert USD to chosen FIAT\n      return (0, helpers_1.formatNumber)(fromAmount / exchangePrice, this.precision.crypto);\n    }\n    return null;\n  }.bind(this);\n  return doExchange;\n}, _CryptoConvert_isSafeKey = function _CryptoConvert_isSafeKey(key) {\n  const functionProto = function () {};\n  return !this.internalMethods.includes(key) && !key.startsWith('__') && !functionProto[key];\n}, _CryptoConvert_setExtendedOptions = function _CryptoConvert_setExtendedOptions(options) {\n  if (options.precision) {\n    for (const precisionKey in options.precision) {\n      if ([\"crypto\", \"fiat\"].includes(precisionKey) && typeof options.precision[precisionKey] == \"number\") {\n        this.precision[precisionKey] = options.precision[precisionKey];\n      }\n    }\n  }\n}, _CryptoConvert_populate = function _CryptoConvert_populate() {\n  let types = '';\n  //Generate typescript interface\n  types += `type amount = (amount: number | string) => number | false | null;`;\n  types += '\\nexport interface Pairs {';\n  const all_currencies = this.worker.list.crypto.concat(this.worker.list.fiat, customWorkers.list);\n  const all_currencies_unique = all_currencies.filter((v, i) => all_currencies.indexOf(v) == i);\n  for (var i = 0; i < all_currencies_unique.length; i++) {\n    var coin = all_currencies_unique[i];\n    if (!coin || typeof coin !== \"string\" || !__classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_isSafeKey).call(this, coin)) {\n      continue;\n    }\n    if (!this[coin]) {\n      this[coin] = {};\n    }\n    types += `\\n\\t'${coin.replace(/\\'/g, \"\\\\'\")}': {`;\n    for (var a = 0; a < all_currencies_unique.length; a++) {\n      var currency = all_currencies_unique[a];\n      if (!currency || typeof currency !== \"string\" || !__classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_isSafeKey).call(this, coin)) {\n        continue;\n      }\n      this[coin][currency] = __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_wrapper).call(this, coin, currency);\n      types += `\\n\\t\\t'${currency.replace(/\\'/g, \"\\\\'\")}': amount,`;\n    }\n    types += '\\n},';\n  }\n  types += '\\n}';\n  //Create types file for Node.js. With Runtime types generation ^^\n  if (typeof window === \"undefined\" && typeof module !== \"undefined\" && typeof process !== \"undefined\") {\n    (function () {\n      return __awaiter(this, void 0, void 0, function* () {\n        try {\n          // Here we save the types file. Using eval because static linting checks on frontend apps are annoying af.\n          eval(`\n\t\t\t\t\t\tconst fs = require('fs');\n\t\t\t\t\t\tconst path = require('path');\n\t\t\t\t\t\tconst isDist = path.basename(__dirname) == 'dist';\n\t\t\t\t\t\tconst typesFile = path.join(__dirname, isDist ? 'paris.d.ts' : 'paris.ts');\n\n\t\t\t\t\t\tfs.writeFileSync(typesFile, types, 'utf-8');\n\t\t\t\t\t`);\n        } catch (err) {\n          console.warn(err);\n        }\n      });\n    })();\n  }\n};\n//@ts-ignore\nCryptoConvert.default = CryptoConvert;\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports = CryptoConvert;\n}\nexports.default = CryptoConvert;","map":{"version":3,"names":["require","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","get","__importDefault","mod","__esModule","_CryptoConvert_instances","_CryptoConvert_getPrice","_CryptoConvert_wrapper","_CryptoConvert_isSafeKey","_CryptoConvert_setExtendedOptions","_CryptoConvert_populate","Object","defineProperty","exports","helpers_1","worker_1","custom_1","customWorkers","default","CryptoConvert","constructor","options","add","precision","fiat","crypto","isBrowser","window","Error","worker","workerReady","run","internalMethods","getOwnPropertyNames","prototype","onCryptoListRefresh","isReady","list","concat","cryptoInfo","lastUpdated","data","last_updated","ticker","setOptions","workerIntervalChanged","cryptoInterval","fiatInterval","hasOwnProperty","refreshCryptoList","useHostedAPI","listLimit","restart","stop","ready","addCurrency","base","rest","removeCurrency","quote","_a","_b","includes","all_currencies","currency","WeakSet","coin","to","customResult","current","toCurrency","doExchange","fromAmount","isEmpty","console","warn","formatNumber","isNaN","fiatCurrencies","cryptoCurrenciesList","exchangePrice","getCryptoPrice","coinPrice","bind","usdPrice","key","functionProto","startsWith","precisionKey","types","all_currencies_unique","filter","v","i","indexOf","length","replace","a","module","process","eval","err"],"sources":["/home/homesasha/Python_Fullstack/CryptoExChange/node_modules/crypto-convert/dist/index.js"],"sourcesContent":["\"use strict\";\r\n/*!\r\n * crypto-convert (c) 2022\r\n * Author: Elis\r\n * License: https://github.com/coinconvert/crypto-convert\r\n */\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nvar _CryptoConvert_instances, _CryptoConvert_getPrice, _CryptoConvert_wrapper, _CryptoConvert_isSafeKey, _CryptoConvert_setExtendedOptions, _CryptoConvert_populate;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst helpers_1 = require(\"./helpers\");\r\nconst worker_1 = __importDefault(require(\"./worker\"));\r\nconst custom_1 = __importDefault(require(\"./custom\"));\r\nconst customWorkers = new custom_1.default();\r\nclass CryptoConvert {\r\n    constructor(options = {}) {\r\n        _CryptoConvert_instances.add(this);\r\n        this.precision = {\r\n            fiat: 4,\r\n            crypto: 8\r\n        };\r\n        if (helpers_1.isBrowser) {\r\n            if (window['__ccInitialized']) {\r\n                throw new Error(\"You have already initalized one instance of crypto-convert. You cannot initialize multiple instances.\");\r\n            }\r\n            window['__ccInitialized'] = true;\r\n        }\r\n        __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_setExtendedOptions).call(this, options);\r\n        this.worker = new worker_1.default(options);\r\n        this.workerReady = this.worker.run();\r\n        this.internalMethods = Object.getOwnPropertyNames(CryptoConvert.prototype);\r\n        Promise.resolve(this.workerReady).then(() => {\r\n            __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_populate).call(this);\r\n            this.worker.onCryptoListRefresh = () => {\r\n                __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_populate).call(this);\r\n            };\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * Quick check if cache has loaded.\r\n     */\r\n    get isReady() {\r\n        return this.worker.isReady;\r\n    }\r\n    /**\r\n     * Supported currencies list\r\n     */\r\n    get list() {\r\n        return {\r\n            'crypto': this.worker.list.crypto.concat(customWorkers.list),\r\n            'fiat': this.worker.list.fiat\r\n        };\r\n    }\r\n    /**\r\n     * Metadata information about cryptocurrencies\r\n     */\r\n    get cryptoInfo() {\r\n        return this.worker.cryptoInfo;\r\n    }\r\n    /**\r\n     * Get crypto prices last updated ms\r\n     */\r\n    get lastUpdated() {\r\n        return this.worker.data.crypto.last_updated;\r\n    }\r\n    /**\r\n     * Price Tickers\r\n     */\r\n    get ticker() {\r\n        return this.worker.data;\r\n    }\r\n    /**\r\n     * Update options\r\n     */\r\n    setOptions(options) {\r\n        __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_setExtendedOptions).call(this, options);\r\n        const workerIntervalChanged = (options.cryptoInterval || options.fiatInterval) && (options.cryptoInterval !== this.worker.options.cryptoInterval ||\r\n            options.fiatInterval !== this.worker.options.fiatInterval);\r\n        if (workerIntervalChanged ||\r\n            (options.hasOwnProperty('refreshCryptoList') && options.refreshCryptoList !== this.worker.options.refreshCryptoList) ||\r\n            (options.hasOwnProperty('useHostedAPI') && options.useHostedAPI !== this.worker.options.useHostedAPI) ||\r\n            (options.listLimit && options.listLimit != this.worker.options.listLimit)) {\r\n            if (!this.worker.isReady) {\r\n                throw new Error(\"You cannot set these options here because CryptoConvert is not ready yet. Instead set the options on the constructor parameter.\");\r\n            }\r\n            //Restart the worker in order to clear interval & update to new interval\r\n            this.workerReady = Promise.resolve(this.worker.setOptions(options))\r\n                .then(() => __awaiter(this, void 0, void 0, function* () {\r\n                yield this.worker.restart();\r\n                if (options.listLimit) {\r\n                    __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_populate).call(this);\r\n                }\r\n                return this.worker;\r\n            }));\r\n            return this.worker;\r\n        }\r\n        return this.worker.setOptions(options);\r\n    }\r\n    /**\r\n     * Stop the worker.\r\n     *\r\n     * It's recommended to do this on Component unmounts (i.e if you are using React).\r\n     */\r\n    stop() {\r\n        return this.worker.stop();\r\n    }\r\n    /**\r\n     * Re-start the worker when it has been stopped.\r\n     */\r\n    restart() {\r\n        this.workerReady = this.worker.restart();\r\n        return this.workerReady;\r\n    }\r\n    /**\r\n     * Promise function that resolves when cache has loaded.\r\n     */\r\n    ready() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield Promise.resolve(this.workerReady);\r\n            yield Promise.resolve(customWorkers.ready());\r\n            return this;\r\n        });\r\n    }\r\n    /**\r\n     * Add a custom currency fetcher. Can be anything.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * convert.addCurrency('ANY','USD', async fetchPrice()=>{\r\n     * \t\t//...call your api here\r\n     * \t\treturn price;\r\n     * }, 10000);\r\n     * ```\r\n     */\r\n    addCurrency(base, ...rest) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.hasOwnProperty(base)) {\r\n                throw new Error(\"This property already exists.\");\r\n            }\r\n            return Promise.resolve(customWorkers.addCurrency.apply(customWorkers, [base, ...rest])).then(() => {\r\n                if (this.worker.isReady) {\r\n                    __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_populate).call(this);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * Remove custom currency fetcher.\r\n     */\r\n    removeCurrency(base, quote) {\r\n        var _a, _b;\r\n        if (customWorkers.list.includes(base) && __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_isSafeKey).call(this, base)) {\r\n            delete this[base];\r\n            const all_currencies = this.worker.list.crypto.concat(this.worker.list.fiat, customWorkers.list);\r\n            for (const currency of all_currencies) {\r\n                if ((_a = this[currency]) === null || _a === void 0 ? void 0 : _a[base]) {\r\n                    (_b = this[currency]) === null || _b === void 0 ? true : delete _b[base];\r\n                }\r\n            }\r\n        }\r\n        return customWorkers.removeCurrency(base, quote);\r\n    }\r\n}\r\n_CryptoConvert_instances = new WeakSet(), _CryptoConvert_getPrice = function _CryptoConvert_getPrice(coin, to = 'USD') {\r\n    var customResult = customWorkers.ticker[coin + to] || (customWorkers.ticker[to + coin] ? 1 / customWorkers.ticker[to + coin] : null);\r\n    var result = this.worker.data.crypto.current[coin + to] || (this.worker.data.crypto.current[to + coin] ? 1 / this.worker.data.crypto.current[to + coin] : null);\r\n    return customResult || result;\r\n}, _CryptoConvert_wrapper = function _CryptoConvert_wrapper(coin, currency) {\r\n    var coin = coin;\r\n    var toCurrency = currency;\r\n    const doExchange = (function (fromAmount) {\r\n        if ((0, helpers_1.isEmpty)(this.worker.data.crypto.current) || (0, helpers_1.isEmpty)(this.worker.data.fiat.current)) {\r\n            console.warn(\"[~] Prices are loading.\\nYou should use `await convert.ready()` to make sure prices are loaded before calling convert.\");\r\n            return false;\r\n        }\r\n        if (!fromAmount) {\r\n            return false;\r\n        }\r\n        fromAmount = (0, helpers_1.formatNumber)(fromAmount);\r\n        if (isNaN(fromAmount)) {\r\n            return false;\r\n        }\r\n        const fiatCurrencies = this.worker.data.fiat.current;\r\n        const cryptoCurrenciesList = this.worker.list.crypto.concat(customWorkers.list);\r\n        //Same\r\n        if (toCurrency == coin) {\r\n            return fromAmount;\r\n        }\r\n        //Crypto to Crypto\r\n        if (cryptoCurrenciesList.includes(coin) && cryptoCurrenciesList.includes(toCurrency)) {\r\n            let exchangePrice = __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_getPrice).call(this, coin, toCurrency) ||\r\n                __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_wrapper).call(this, \"USD\", toCurrency)(__classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_wrapper).call(this, coin, \"USD\")(1));\r\n            return (0, helpers_1.formatNumber)(exchangePrice * fromAmount, this.precision.crypto);\r\n        }\r\n        //Fiat to Fiat\r\n        if (fiatCurrencies[coin] && fiatCurrencies[toCurrency]) {\r\n            return (0, helpers_1.formatNumber)(((fromAmount / fiatCurrencies[coin]) * fiatCurrencies[toCurrency]), this.precision.fiat);\r\n        }\r\n        //Crypto->Fiat || Crypto->BTC->Fiat\r\n        var getCryptoPrice = (function (coin) {\r\n            var coinPrice = __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_getPrice).call(this, coin) ||\r\n                __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_wrapper).call(this, \"BTC\", \"USD\")(__classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_getPrice).call(this, coin, \"BTC\")) ||\r\n                __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_wrapper).call(this, \"ETH\", \"USD\")(__classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_getPrice).call(this, coin, \"ETH\"));\r\n            return coinPrice;\r\n        }).bind(this);\r\n        //Crypto to Fiat\r\n        if (fiatCurrencies[toCurrency]) {\r\n            let usdPrice = getCryptoPrice(coin);\r\n            let exchangePrice = (usdPrice / fiatCurrencies['USD']) * fiatCurrencies[toCurrency]; //Convert USD to chosen FIAT\r\n            return (0, helpers_1.formatNumber)(exchangePrice * fromAmount, this.precision.crypto);\r\n        }\r\n        //Fiat to Crypto\r\n        if (fiatCurrencies[coin]) {\r\n            let usdPrice = getCryptoPrice(toCurrency);\r\n            let exchangePrice = (usdPrice / fiatCurrencies['USD']) * fiatCurrencies[coin]; //Convert USD to chosen FIAT\r\n            return (0, helpers_1.formatNumber)(fromAmount / exchangePrice, this.precision.crypto);\r\n        }\r\n        return null;\r\n    }).bind(this);\r\n    return doExchange;\r\n}, _CryptoConvert_isSafeKey = function _CryptoConvert_isSafeKey(key) {\r\n    const functionProto = function () { };\r\n    return (!this.internalMethods.includes(key) &&\r\n        !key.startsWith('__') &&\r\n        !functionProto[key]);\r\n}, _CryptoConvert_setExtendedOptions = function _CryptoConvert_setExtendedOptions(options) {\r\n    if (options.precision) {\r\n        for (const precisionKey in options.precision) {\r\n            if ([\"crypto\", \"fiat\"].includes(precisionKey) && typeof options.precision[precisionKey] == \"number\") {\r\n                this.precision[precisionKey] = options.precision[precisionKey];\r\n            }\r\n        }\r\n    }\r\n}, _CryptoConvert_populate = function _CryptoConvert_populate() {\r\n    let types = '';\r\n    //Generate typescript interface\r\n    types += `type amount = (amount: number | string) => number | false | null;`;\r\n    types += '\\nexport interface Pairs {';\r\n    const all_currencies = this.worker.list.crypto.concat(this.worker.list.fiat, customWorkers.list);\r\n    const all_currencies_unique = all_currencies.filter((v, i) => all_currencies.indexOf(v) == i);\r\n    for (var i = 0; i < all_currencies_unique.length; i++) {\r\n        var coin = all_currencies_unique[i];\r\n        if (!coin || typeof coin !== \"string\" || !__classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_isSafeKey).call(this, coin)) {\r\n            continue;\r\n        }\r\n        if (!this[coin]) {\r\n            this[coin] = {};\r\n        }\r\n        types += `\\n\\t'${coin.replace(/\\'/g, \"\\\\'\")}': {`;\r\n        for (var a = 0; a < all_currencies_unique.length; a++) {\r\n            var currency = all_currencies_unique[a];\r\n            if (!currency || typeof currency !== \"string\" || !__classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_isSafeKey).call(this, coin)) {\r\n                continue;\r\n            }\r\n            this[coin][currency] = __classPrivateFieldGet(this, _CryptoConvert_instances, \"m\", _CryptoConvert_wrapper).call(this, coin, currency);\r\n            types += `\\n\\t\\t'${currency.replace(/\\'/g, \"\\\\'\")}': amount,`;\r\n        }\r\n        types += '\\n},';\r\n    }\r\n    types += '\\n}';\r\n    //Create types file for Node.js. With Runtime types generation ^^\r\n    if (typeof window === \"undefined\" && typeof module !== \"undefined\" && typeof process !== \"undefined\") {\r\n        (function () {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    // Here we save the types file. Using eval because static linting checks on frontend apps are annoying af.\r\n                    eval(`\r\n\t\t\t\t\t\tconst fs = require('fs');\r\n\t\t\t\t\t\tconst path = require('path');\r\n\t\t\t\t\t\tconst isDist = path.basename(__dirname) == 'dist';\r\n\t\t\t\t\t\tconst typesFile = path.join(__dirname, isDist ? 'paris.d.ts' : 'paris.ts');\r\n\r\n\t\t\t\t\t\tfs.writeFileSync(typesFile, types, 'utf-8');\r\n\t\t\t\t\t`);\r\n                }\r\n                catch (err) {\r\n                    console.warn(err);\r\n                }\r\n            });\r\n        })();\r\n    }\r\n};\r\n//@ts-ignore\r\nCryptoConvert.default = CryptoConvert;\r\nif (typeof module !== \"undefined\" && module.exports) {\r\n    module.exports = CryptoConvert;\r\n}\r\nexports.default = CryptoConvert;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}